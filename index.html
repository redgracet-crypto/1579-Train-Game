<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Holiday Train Hop ‚Äî Daily Gauntlet</title>
  <style>
    html,body{margin:0;height:100%;background:#0b1020;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
    #wrap{display:flex;flex-direction:column;height:100%}
    #hud{
      padding:10px 12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;
      background:rgba(0,0,0,.30);backdrop-filter:blur(6px)
    }
    #msg{margin-left:auto;opacity:.95;min-width:260px;text-align:right}
    button{
      border:0;border-radius:14px;padding:10px 14px;cursor:pointer;
      background:rgba(255,255,255,.12);color:#fff;font-weight:900
    }
    button:hover{background:rgba(255,255,255,.18)}
    button:disabled{opacity:.45;cursor:not-allowed}
    canvas{width:100%;height:100%;display:block;touch-action:none}

    .overlay{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,.58);backdrop-filter:blur(6px);z-index:9999;padding:18px
    }
    .card{
      width:min(680px,94vw);
      background:rgba(10,12,22,.92);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:16px;
      box-shadow:0 18px 40px rgba(0,0,0,.45)
    }
    .card h2{margin:0 0 10px 0;font-size:18px}
    .sub{opacity:.85;font-size:13px;margin-bottom:12px;line-height:1.35}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .pill{
      display:flex;gap:10px;align-items:center;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px 12px;
      font-size:14px
    }
    .key{
      display:inline-flex;align-items:center;justify-content:center;
      min-width:32px;height:32px;padding:0 10px;
      border-radius:12px;
      background:rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.18);
      font-weight:900;
      font-variant-numeric:tabular-nums
    }
    .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:12px;flex-wrap:wrap}

    #lbList{display:flex;flex-direction:column;gap:8px;margin:10px 0 14px 0}
    .lbRow{display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:10px 12px;font-size:14px}
    .lbRow .left{display:flex;gap:10px;align-items:center}
    .rank{width:26px;height:26px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.10);font-weight:900}
    .lbRow .name{font-weight:800}
    .lbRow .meta{opacity:.85;font-variant-numeric:tabular-nums}
  </style>
</head>

<body>
<div id="wrap">
  <div id="hud">
    <button id="startBtn">Start Daily Run</button>
    <button id="controlsBtn">Controls</button>
    <button id="leaderBtn">Leaderboard</button>

    <div>User: <b id="userLabel">‚Äî</b></div>
    <div>Day: <b id="dayLabel">‚Äî</b></div>
    <div>Lives: <b id="livesLabel">3</b></div>
    <div>Time: <b id="timeLabel">10.0</b>s</div>
    <div>Score: <b id="scoreLabel">0</b></div>

    <div id="msg">Loading‚Ä¶</div>
  </div>

  <canvas id="c"></canvas>
</div>

<!-- Controls Overlay -->
<div id="controlsOverlay" class="overlay">
  <div class="card">
    <h2>üéÆ Controls</h2>
    <div class="sub">
      <b>3 lives</b> ‚Ä¢ <b>10 seconds</b> ‚Ä¢ score = obstacles cleared. <br/>
      Desktop: <b>Space</b> or click. Mobile: <b>tap</b> anywhere on the game area.
    </div>

    <div class="row">
      <div class="pill"><span class="key">Space</span><span>Jump</span></div>
      <div class="pill"><span class="key">Click</span><span>Jump</span></div>
      <div class="pill"><span class="key">Tap</span><span>Jump (mobile)</span></div>
    </div>

    <div class="sub" style="margin-top:10px">
      Tip: it‚Äôs intentionally mean. Don‚Äôt spam jump ‚Äî time it.
    </div>

    <div class="actions">
      <button id="controlsClose">Close & Play</button>
    </div>
  </div>
</div>

<!-- Leaderboard Overlay -->
<div id="lbOverlay" class="overlay">
  <div class="card">
    <h2>üöÇ Daily Leaderboard</h2>
    <div class="sub" id="lbSub">‚Äî</div>
    <div id="lbList"></div>
    <div class="actions">
      <button id="lbClose">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ‚úÖ Your working Apps Script endpoint
  const API_URL = "https://script.google.com/macros/s/AKfycbwQQCcwb4AQSDFsoGCN6jxHrU2An58X6df0ZIfH_fJ7F4Ae1isuxz_fQaS2dv7FEMOJ-A/exec";

  // Event window
  const START = new Date("2025-12-20T00:01:00");
  const END   = new Date("2025-12-30T23:59:59");

  // Game settings
  const RUN_SECONDS = 10.0;
  const MAX_LIVES = 3;

  // === SPRITE SHEET CONFIG ===
  // You can tweak these numbers later to perfectly crop your SpriteSheet2.png
  // Coordinates are in *pixels* inside SpriteSheet2.png
  const SPRITES = {
    elf:      { x:  40, y: 320, w: 260, h: 220 }, // <-- adjust
    spike:    { x: 450, y: 340, w: 260, h: 200 }, // <-- adjust
    snowman:  { x: 780, y: 250, w: 260, h: 330 }, // <-- adjust
  };

  // If you want the elf to look like it's "running", we can later make multiple frames.
  // For now: one cute static sprite works great.

  // UI refs
  const msgEl = document.getElementById("msg");
  const userEl = document.getElementById("userLabel");
  const dayEl = document.getElementById("dayLabel");
  const livesEl = document.getElementById("livesLabel");
  const timeEl = document.getElementById("timeLabel");
  const scoreEl = document.getElementById("scoreLabel");

  const startBtn = document.getElementById("startBtn");
  const controlsBtn = document.getElementById("controlsBtn");
  const leaderBtn = document.getElementById("leaderBtn");

  const controlsOverlay = document.getElementById("controlsOverlay");
  const controlsClose = document.getElementById("controlsClose");

  const lbOverlay = document.getElementById("lbOverlay");
  const lbClose = document.getElementById("lbClose");
  const lbList = document.getElementById("lbList");
  const lbSub = document.getElementById("lbSub");

  // Canvas
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize(){
    const r = canvas.getBoundingClientRect();
    canvas.width = Math.floor(r.width * devicePixelRatio);
    canvas.height = Math.floor(r.height * devicePixelRatio);
  }
  window.addEventListener("resize", resize);
  resize();

  // Images
  const bgImg = new Image();
  bgImg.src = "background.png";

  const sheet = new Image();
  sheet.src = "SpriteSheet2.png";

  let assetsReady = false;
  Promise.all([
    new Promise(res => bgImg.onload = res),
    new Promise(res => sheet.onload = res),
  ]).then(() => {
    assetsReady = true;
    drawScene(0);
    msgEl.textContent = "Ready.";
  }).catch(() => {
    msgEl.textContent = "‚ö†Ô∏è Couldn‚Äôt load images. Check filenames: background.png and SpriteSheet2.png";
  });

  // ========= JSONP =========
  function jsonp(url){
    return new Promise((resolve, reject) => {
      const cbName = "cb_" + Math.random().toString(36).slice(2);
      const s = document.createElement("script");
      const timeout = setTimeout(() => { cleanup(); reject(new Error("timeout")); }, 12000);

      function cleanup(){
        clearTimeout(timeout);
        try { delete window[cbName]; } catch {}
        s.remove();
      }

      window[cbName] = (data) => { cleanup(); resolve(data); };
      s.onerror = () => { cleanup(); reject(new Error("load error")); };

      const sep = url.includes("?") ? "&" : "?";
      s.src = url + sep + "callback=" + cbName;
      document.head.appendChild(s);
    });
  }

  async function apiCall(params){
    params._ = String(Date.now());
    const url = API_URL + "?" + new URLSearchParams(params).toString();
    return await jsonp(url);
  }

  const checkinNameForToday = (name, day) => apiCall({ action:"checkin", name, day });
  const submitScore = (name, day, score, time) => apiCall({ action:"submit", name, day, score:String(score), time:String(time) });
  const fetchLeaderboard = (day, limit=10) => apiCall({ action:"leaderboard", mode:"today", day, limit:String(limit) });

  // ========= User name =========
  const USER_KEY = "trainhop_username";
  function sanitizeName(s){
    s = (s || "").trim().replace(/[^\w\s\-'.!]/g, "");
    if (s.length > 18) s = s.slice(0,18);
    return s;
  }
  function getUsername(){ return localStorage.getItem(USER_KEY) || ""; }
  function setUsername(name){
    localStorage.setItem(USER_KEY, name);
    userEl.textContent = name || "‚Äî";
  }
  function bootstrapUser(){
    let name = sanitizeName(getUsername());
    if (!name){
      name = sanitizeName(prompt("1579 name for leaderboard? (use same every day)") || "");
      if (!name) name = "Guest";
      setUsername(name);
    } else userEl.textContent = name;
  }

  // ========= Date helpers =========
  function pad2(n){ return String(n).padStart(2,"0"); }
  function ymd(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
  function inWindow(now){ return now>=START && now<=END; }
  function dayIndex(now){
    const startMid = new Date(START.getFullYear(), START.getMonth(), START.getDate());
    const nowMid = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    return Math.floor((nowMid - startMid)/(24*60*60*1000)) + 1;
  }

  // Gate ticker
  let gateTicker = null;
  function startGateTicker(){ stopGateTicker(); gateTicker = setInterval(updateGateUI, 15000); }
  function stopGateTicker(){ if (gateTicker) clearInterval(gateTicker); gateTicker = null; }

  // ========= Game state =========
  let running = false;
  let paused = false;     // <- new
  let rafId = 0;

  let checkedIn = false;
  let submitted = false;

  let lives = MAX_LIVES;
  let score = 0;

  let startTs = 0;
  let lastTs = 0;
  let remaining = RUN_SECONDS;

  // PRNG
  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
  function seedFromDay(d){
    const s = d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate();
    return s ^ 0xA5B3571;
  }
  let rand = mulberry32(seedFromDay(new Date()));

  // Player (normalized)
  const player = { x:0.18, y:0.78, vy:0, onGround:true };

  // Obstacles
  let obstacles = [];
  let spawnT = 0;
  let difficulty = 0;

  function setScore(n){ score=n; scoreEl.textContent = String(score); }
  function setLives(n){ lives=n; livesEl.textContent = String(lives); }
  function setTime(sec){ timeEl.textContent = sec.toFixed(1); }

  function resetRun(){
    setLives(MAX_LIVES);
    setScore(0);
    remaining = RUN_SECONDS;
    setTime(remaining);

    player.y = 0.82 - 0.06;
    player.vy = 0;
    player.onGround = true;

    obstacles = [];
    spawnT = 0;
    difficulty = 0;

    submitted = false;
    startTs = 0;
    lastTs = 0;
  }

  // ========= Overlays -> pause logic =========
  function setControlsOpen(open){
    controlsOverlay.style.display = open ? "flex" : "none";
    if (running){
      paused = open;
      if (paused){
        msgEl.textContent = "‚è∏ Paused ‚Äî close Controls to continue.";
      } else {
        msgEl.textContent = "üöÇ GO!";
        // resume loop
        lastTs = performance.now();
        cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(step);
      }
    }
  }

  controlsBtn.addEventListener("click", () => setControlsOpen(true));
  controlsClose.addEventListener("click", () => setControlsOpen(false));
  controlsOverlay.addEventListener("click", (e)=>{ if(e.target===controlsOverlay) setControlsOpen(false); });

  lbClose.addEventListener("click", () => lbOverlay.style.display = "none");
  lbOverlay.addEventListener("click", (e)=>{ if(e.target===lbOverlay) lbOverlay.style.display="none"; });

  // ========= Drawing helpers =========
  function drawBackground(){
    const W=canvas.width, H=canvas.height;
    if(bgImg.complete){
      const s = Math.max(W/bgImg.width, H/bgImg.height);
      const w=bgImg.width*s, h=bgImg.height*s;
      ctx.drawImage(bgImg, (W-w)/2, (H-h)/2, w, h);
    } else {
      ctx.fillStyle = "#0b1020";
      ctx.fillRect(0,0,W,H);
    }
  }

  function drawSprite(key, dx, dy, dw, dh){
    const sp = SPRITES[key];
    if (!sp || !sheet.complete) return;
    ctx.drawImage(sheet, sp.x, sp.y, sp.w, sp.h, dx, dy, dw, dh);
  }

  function drawScene(){
    const W=canvas.width, H=canvas.height;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    drawBackground();
    ctx.fillStyle = "rgba(0,0,0,.14)";
    ctx.fillRect(0,0,W,H);

    // snowman dressing (right side, near ground)
    const groundY = Math.floor(H*0.82);
    drawSprite("snowman", Math.floor(W*0.82), Math.floor(groundY - H*0.30), Math.floor(W*0.14), Math.floor(H*0.30));

    // ground line
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = Math.max(2, Math.floor(devicePixelRatio*1.5));
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(W, groundY);
    ctx.stroke();

    // player sprite
    const pw = Math.max(34*devicePixelRatio, W*0.06);
    const ph = Math.max(34*devicePixelRatio, H*0.10);
    const px = W * player.x;
    const py = H * player.y;
    drawSprite("elf", px, py, pw, ph);

    // obstacles (spikes)
    obstacles.forEach(o=>{
      const ox = W * o.x;
      const oy = H * o.y;
      const ow = W * o.w;
      const oh = H * o.h;
      drawSprite("spike", ox, oy, ow, oh);
    });

    // paused hint
    if (running && paused){
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = `${Math.max(16*devicePixelRatio, 20)}px system-ui`;
      ctx.fillText("Paused ‚Äî close Controls to continue", Math.floor(W*0.04), Math.floor(H*0.10));
    }
  }

  // ========= Mechanics =========
  function jump(){
    if (!running || paused) return;
    if (player.onGround){
      player.vy = -1.05;
      player.onGround = false;
    }
  }

  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  function spawnObstacle(){
    const baseW = 0.020 + 0.010 * (1 - Math.min(1, difficulty));
    const w = Math.max(0.012, baseW + (rand()-0.5)*0.006);

    const h = 0.10 + rand()*0.18 + difficulty*0.06;
    const height = Math.min(0.34, Math.max(0.10, h));

    obstacles.push({
      x: 1.05,
      y: 0.82 - height,
      w,
      h: height,
      passed: false,
    });
  }

  function step(ts){
    if (!running) return;
    if (paused){
      drawScene();
      rafId = requestAnimationFrame(step);
      return;
    }

    if (!startTs){ startTs = ts; lastTs = ts; }
    const dt = Math.min(0.035, (ts - lastTs) / 1000);
    lastTs = ts;

    remaining = Math.max(0, RUN_SECONDS - (ts - startTs)/1000);
    setTime(remaining);

    const t = 1 - (remaining / RUN_SECONDS);
    difficulty = Math.min(1, 0.15 + t*0.95);

    // gravity
    player.vy += 2.45 * dt;
    player.y += player.vy * dt;

    const groundTop = 0.82 - 0.10; // slightly higher because sprite is taller
    if (player.y >= groundTop){
      player.y = groundTop;
      player.vy = 0;
      player.onGround = true;
    }

    const speed = 0.62 + difficulty*0.95;

    spawnT -= dt;
    if (spawnT <= 0){
      spawnObstacle();
      const minGap = 0.45 - difficulty*0.22;
      const jitter = (rand()*0.22);
      spawnT = Math.max(0.18, minGap + jitter);
    }

    obstacles.forEach(o => o.x -= speed * dt);

    // collision + scoring (hitbox smaller than sprite)
    const px = player.x + 0.010;
    const py = player.y + 0.018;
    const pw = 0.035;
    const ph = 0.070;

    for (const o of obstacles){
      if (!o.passed && o.x + o.w < player.x){
        o.passed = true;
        setScore(score + 1);
      }

      // spike hitbox slightly inset too
      const bx = o.x + 0.004;
      const by = o.y + 0.010;
      const bw = Math.max(0.01, o.w - 0.008);
      const bh = Math.max(0.01, o.h - 0.014);

      if (aabb(px,py,pw,ph, bx,by,bw,bh)){
        setLives(lives - 1);
        player.vy = -0.75;
        player.onGround = false;
        o.x = player.x - o.w - 0.02;

        if (lives <= 0){
          endRun(false);
          return;
        }
      }
    }

    obstacles = obstacles.filter(o => o.x > -0.25);

    drawScene();

    if (remaining <= 0){
      endRun(true);
      return;
    }

    rafId = requestAnimationFrame(step);
  }

  async function endRun(survived){
    running = false;
    paused = false;
    stopGateTicker();
    startBtn.disabled = true;

    const now = new Date();
    const day = ymd(now);
    const name = sanitizeName(getUsername()) || "Guest";
    const timeTaken = RUN_SECONDS - remaining;

    const flavor = survived ? "‚úÖ Run complete!" : "üí• Wiped out!";
    msgEl.textContent = `${flavor} Submitting score‚Ä¶`;

    if (submitted){
      msgEl.textContent = `${flavor} (Already submitted.)`;
      startGateTicker();
      return;
    }

    try{
      const r = await submitScore(name, day, score, timeTaken);
      submitted = true;
      msgEl.textContent = (r && r.ok)
        ? `üèÅ ${flavor} Score: ${score}. Posted to leaderboard.`
        : `‚ö†Ô∏è ${flavor} Score: ${score}. Submit failed (server).`;
    }catch{
      msgEl.textContent = `‚ö†Ô∏è ${flavor} Score: ${score}. Submit failed (network).`;
    }

    await openLeaderboard();
    startGateTicker();
  }

  // ========= Leaderboard =========
  function renderLeaderboardList(rows){
    lbList.innerHTML = "";
    if (!rows || rows.length === 0){
      lbList.innerHTML = `<div class="lbRow"><div class="left"><div class="rank">‚Äî</div><div class="name">No scores yet today</div></div><div class="meta">‚ùÑÔ∏è</div></div>`;
      return;
    }
    rows.forEach((r,i)=>{
      const el = document.createElement("div");
      el.className="lbRow";
      el.innerHTML = `<div class="left"><div class="rank">${i+1}</div><div class="name">${String(r.name||"").replace(/</g,"&lt;")}</div></div><div class="meta">${r.score} pts ‚Ä¢ ${Number(r.time||0).toFixed(1)}s</div>`;
      lbList.appendChild(el);
    });
  }

  async function openLeaderboard(){
    const now = new Date();
    const day = ymd(now);
    lbSub.textContent = `Day ${dayIndex(now)} / 11 ‚Ä¢ ${day}`;
    try{
      const r = await fetchLeaderboard(day, 10);
      if (r && r.ok) renderLeaderboardList(r.top || []);
      else renderLeaderboardList([]);
    }catch{
      renderLeaderboardList([]);
    }
    lbOverlay.style.display = "flex";
  }
  leaderBtn.addEventListener("click", openLeaderboard);

  // ========= Start flow (wait for controls close) =========
  function waitForControlsClose(){
    return new Promise(resolve => {
      // If already closed, resolve immediately
      if (controlsOverlay.style.display !== "flex") return resolve();

      const handler = () => {
        // When it becomes hidden, resolve
        if (controlsOverlay.style.display !== "flex") {
          controlsClose.removeEventListener("click", handler);
          resolve();
        }
      };
      controlsClose.addEventListener("click", handler);
    });
  }

  async function startDailyRun(){
    const now = new Date();
    if (!inWindow(now)) { updateGateUI(); return; }
    if (!assetsReady){
      msgEl.textContent = "‚è≥ Loading images‚Ä¶";
      return;
    }

    bootstrapUser();
    const name = sanitizeName(getUsername()) || "Guest";
    const day = ymd(now);

    startBtn.disabled = true;
    msgEl.textContent = "Checking in (one play per name per day)‚Ä¶";

    try{
      const r = await checkinNameForToday(name, day);
      if (!r || !r.ok){
        msgEl.textContent = "‚ö†Ô∏è Server error. Try again.";
        startBtn.disabled = false;
        return;
      }
      if (!r.allowed){
        checkedIn = true;
        msgEl.textContent = "‚úÖ Already played today (for this name). Come back tomorrow!";
        startBtn.disabled = true;
        await openLeaderboard();
        return;
      }

      checkedIn = true;
      resetRun();
      running = true;
      paused = true; // <- start paused until controls is closed
      stopGateTicker();

      // Show controls and WAIT until they close it
      setControlsOpen(true);
      msgEl.textContent = `‚è∏ Ready, ${name}. Close Controls to start!`;

      await waitForControlsClose();

      // Start for real
      paused = false;
      msgEl.textContent = `üöÇ GO, ${name}! Tap/Click/Space to jump.`;
      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(step);

    }catch{
      msgEl.textContent = "‚ö†Ô∏è Network error. Try again.";
      startBtn.disabled = false;
    }
  }
  startBtn.addEventListener("click", startDailyRun);

  // Pointer + keyboard jump (ignore if controls open)
  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space"){
      e.preventDefault();
      if (controlsOverlay.style.display === "flex") return;
      jump();
    }
  });

  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    if (controlsOverlay.style.display === "flex") return; // don't jump behind overlay
    jump();
  }, { passive:false });

  // ========= Gate UI =========
  function updateGateUI(){
    const now = new Date();
    bootstrapUser();

    if (now < START){
      msgEl.textContent = "üöÇ Not open yet. Opens 12/20/2025 at 00:01.";
      startBtn.disabled = true;
      dayEl.textContent = "‚Äî";
      return;
    }
    if (now > END){
      msgEl.textContent = "‚ùÑÔ∏è Event ended. Closed after 12/30/2025 23:59.";
      startBtn.disabled = true;
      dayEl.textContent = "‚Äî";
      return;
    }

    dayEl.textContent = `${dayIndex(now)} / 11`;
    if (!running) msgEl.textContent = "üéÅ One play per name per day. Good luck.";
    startBtn.disabled = running ? true : false;
  }

  // Controls button should pause if opened mid-run
  controlsBtn.addEventListener("click", ()=>setControlsOpen(true));

  // ========= Init =========
  bootstrapUser();
  updateGateUI();
  startGateTicker();

  function safeDrawInit(){
    if (!assetsReady) return;
    drawScene();
  }
  safeDrawInit();
})();
</script>
</body>
</html>

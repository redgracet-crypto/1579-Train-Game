<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Holiday Train Hop ‚Äî Daily Gauntlet</title>
  <style>
    html,body{margin:0;height:100%;background:#0b1020;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
    #wrap{display:flex;flex-direction:column;height:100%}
    #hud{
      padding:10px 12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;
      background:rgba(0,0,0,.30);backdrop-filter:blur(6px)
    }
    #msg{margin-left:auto;opacity:.95;min-width:260px;text-align:right}
    button{
      border:0;border-radius:14px;padding:10px 14px;cursor:pointer;
      background:rgba(255,255,255,.12);color:#fff;font-weight:900
    }
    button:hover{background:rgba(255,255,255,.18)}
    button:disabled{opacity:.45;cursor:not-allowed}
    canvas{width:100%;height:100%;display:block;touch-action:none}

    .overlay{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,.58);backdrop-filter:blur(6px);z-index:9999;padding:18px
    }
    .card{
      width:min(680px,94vw);
      background:rgba(10,12,22,.92);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:16px;
      box-shadow:0 18px 40px rgba(0,0,0,.45)
    }
    .card h2{margin:0 0 10px 0;font-size:18px}
    .sub{opacity:.85;font-size:13px;margin-bottom:12px;line-height:1.35}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .pill{
      display:flex;gap:10px;align-items:center;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px 12px;
      font-size:14px
    }
    .key{
      display:inline-flex;align-items:center;justify-content:center;
      min-width:32px;height:32px;padding:0 10px;
      border-radius:12px;
      background:rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.18);
      font-weight:900;
      font-variant-numeric:tabular-nums
    }
    .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:12px;flex-wrap:wrap}

    #lbList{display:flex;flex-direction:column;gap:8px;margin:10px 0 14px 0}
    .lbRow{display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:10px 12px;font-size:14px}
    .lbRow .left{display:flex;gap:10px;align-items:center}
    .rank{width:26px;height:26px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.10);font-weight:900}
    .lbRow .name{font-weight:800}
    .lbRow .meta{opacity:.85;font-variant-numeric:tabular-nums}
  </style>
</head>

<body>
<div id="wrap">
  <div id="hud">
    <button id="startBtn">Start Daily Run</button>
    <button id="controlsBtn">Controls</button>
    <button id="leaderBtn">Leaderboard</button>

    <div>User: <b id="userLabel">‚Äî</b></div>
    <div>Day: <b id="dayLabel">‚Äî</b></div>
    <div>Lives: <b id="livesLabel">3</b></div>
    <div>Time: <b id="timeLabel">10.0</b>s</div>
    <div>Score: <b id="scoreLabel">0</b></div>

    <div id="msg">Loading‚Ä¶</div>
  </div>

  <canvas id="c"></canvas>
</div>

<!-- Controls Overlay -->
<div id="controlsOverlay" class="overlay">
  <div class="card">
    <h2>üéÆ Controls</h2>
    <div class="sub">
      <b>3 lives</b> ‚Ä¢ <b>10 seconds</b> ‚Ä¢ score = obstacles cleared. <br/>
      Desktop: <b>Space</b> or click. Mobile: <b>tap</b> anywhere on the game area.
    </div>

    <div class="row">
      <div class="pill"><span class="key">Space</span><span>Jump</span></div>
      <div class="pill"><span class="key">Click</span><span>Jump</span></div>
      <div class="pill"><span class="key">Tap</span><span>Jump (mobile)</span></div>
    </div>

    <div class="sub" style="margin-top:10px">
      Tip: it‚Äôs intentionally mean. Don‚Äôt spam jump ‚Äî time it.
    </div>

    <div class="actions">
      <button id="controlsClose">Close & Play</button>
    </div>
  </div>
</div>

<!-- Leaderboard Overlay -->
<div id="lbOverlay" class="overlay">
  <div class="card">
    <h2>üöÇ Daily Leaderboard</h2>
    <div class="sub" id="lbSub">‚Äî</div>
    <div id="lbList"></div>
    <div class="actions">
      <button id="lbClose">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ‚úÖ Apps Script endpoint
  const API_URL = "https://script.google.com/macros/s/AKfycbwQQCcwb4AQSDFsoGCN6jxHrU2An58X6df0ZIfH_fJ7F4Ae1isuxz_fQaS2dv7FEMOJ-A/exec";

  // Event window
  const START = new Date("2025-12-20T00:01:00");
  const END   = new Date("2025-12-30T23:59:59");

  // Game settings
  const RUN_SECONDS = 10.0;
  const MAX_LIVES = 3;

  // UI refs
  const msgEl = document.getElementById("msg");
  const userEl = document.getElementById("userLabel");
  const dayEl = document.getElementById("dayLabel");
  const livesEl = document.getElementById("livesLabel");
  const timeEl = document.getElementById("timeLabel");
  const scoreEl = document.getElementById("scoreLabel");

  const startBtn = document.getElementById("startBtn");
  const controlsBtn = document.getElementById("controlsBtn");
  const leaderBtn = document.getElementById("leaderBtn");

  const controlsOverlay = document.getElementById("controlsOverlay");
  const controlsClose = document.getElementById("controlsClose");

  const lbOverlay = document.getElementById("lbOverlay");
  const lbClose = document.getElementById("lbClose");
  const lbList = document.getElementById("lbList");
  const lbSub = document.getElementById("lbSub");

  // Canvas
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize(){
    const r = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(r.width * devicePixelRatio));
    canvas.height = Math.max(1, Math.floor(r.height * devicePixelRatio));
  }
  window.addEventListener("resize", resize);
  resize();

  // Background image is OPTIONAL. If it fails, we just draw a gradient.
  const bgImg = new Image();
  bgImg.src = "background.png";

  // Robust asset loader (won't hang forever)
  let assetsReady = false;
  function loadOptionalImage(img){
    return new Promise((res) => {
      img.onload = () => res(true);
      img.onerror = () => res(false);
      // src already set
      // If the browser cached the error, we still resolve
      if (img.complete) setTimeout(()=>res(true), 0);
    });
  }

  loadOptionalImage(bgImg).then(() => {
    assetsReady = true;
    drawScene();
    msgEl.textContent = "Ready.";
  });

  // ========= JSONP =========
  function jsonp(url){
    return new Promise((resolve, reject) => {
      const cbName = "cb_" + Math.random().toString(36).slice(2);
      const s = document.createElement("script");
      const timeout = setTimeout(() => { cleanup(); reject(new Error("timeout")); }, 12000);

      function cleanup(){
        clearTimeout(timeout);
        try { delete window[cbName]; } catch {}
        s.remove();
      }

      window[cbName] = (data) => { cleanup(); resolve(data); };
      s.onerror = () => { cleanup(); reject(new Error("load error")); };

      const sep = url.includes("?") ? "&" : "?";
      s.src = url + sep + "callback=" + cbName;
      document.head.appendChild(s);
    });
  }

  async function apiCall(params){
    params._ = String(Date.now());
    const url = API_URL + "?" + new URLSearchParams(params).toString();
    return await jsonp(url);
  }

  const checkinNameForToday = (name, day) => apiCall({ action:"checkin", name, day });
  const submitScore = (name, day, score, time) => apiCall({ action:"submit", name, day, score:String(score), time:String(time) });
  const fetchLeaderboard = (day, limit=10) => apiCall({ action:"leaderboard", mode:"today", day, limit:String(limit) });

  // ========= User name =========
  const USER_KEY = "trainhop_username";
  function sanitizeName(s){
    s = (s || "").trim().replace(/[^\w\s\-'.!]/g, "");
    if (s.length > 18) s = s.slice(0,18);
    return s;
  }
  function getUsername(){ return localStorage.getItem(USER_KEY) || ""; }
  function setUsername(name){
    localStorage.setItem(USER_KEY, name);
    userEl.textContent = name || "‚Äî";
  }
  function bootstrapUser(){
    let name = sanitizeName(getUsername());
    if (!name){
      name = sanitizeName(prompt("1579 name for leaderboard? (use same every day)") || "");
      if (!name) name = "Guest";
      setUsername(name);
    } else userEl.textContent = name;
  }

  // ========= Date helpers =========
  function pad2(n){ return String(n).padStart(2,"0"); }
  function ymd(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
  function inWindow(now){ return now>=START && now<=END; }
  function dayIndex(now){
    const startMid = new Date(START.getFullYear(), START.getMonth(), START.getDate());
    const nowMid = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    return Math.floor((nowMid - startMid)/(24*60*60*1000)) + 1;
  }

  // Gate ticker
  let gateTicker = null;
  function startGateTicker(){ stopGateTicker(); gateTicker = setInterval(updateGateUI, 15000); }
  function stopGateTicker(){ if (gateTicker) clearInterval(gateTicker); gateTicker = null; }

  // ========= Game state =========
  let running = false;
  let paused = false;
  let rafId = 0;

  let lives = MAX_LIVES;
  let score = 0;

  let startTs = 0;
  let lastTs = 0;
  let remaining = RUN_SECONDS;

  // PRNG
  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
  function seedFromDay(d){
    const s = d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate();
    return s ^ 0xA5B3571;
  }
  let rand = mulberry32(seedFromDay(new Date()));

  // Player (normalized)
  const player = { x:0.18, y:0.72, vy:0, onGround:true };

  // Obstacles
  let obstacles = [];
  let spawnT = 0;
  let difficulty = 0;

  function setScore(n){ score=n; scoreEl.textContent = String(score); }
  function setLives(n){ lives=n; livesEl.textContent = String(lives); }
  function setTime(sec){ timeEl.textContent = sec.toFixed(1); }

  function resetRun(){
    setLives(MAX_LIVES);
    setScore(0);
    remaining = RUN_SECONDS;
    setTime(remaining);

    player.y = 0.72;
    player.vy = 0;
    player.onGround = true;

    obstacles = [];
    spawnT = 0;
    difficulty = 0;

    startTs = 0;
    lastTs = 0;
  }

  // ========= Overlays -> pause logic =========
  function setControlsOpen(open){
    controlsOverlay.style.display = open ? "flex" : "none";
    if (running){
      paused = open;
      if (paused){
        msgEl.textContent = "‚è∏ Paused ‚Äî close Controls to continue.";
      } else {
        msgEl.textContent = "üöÇ GO!";
        lastTs = performance.now();
        cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(step);
      }
    }
  }

  controlsBtn.addEventListener("click", () => setControlsOpen(true));
  controlsClose.addEventListener("click", () => setControlsOpen(false));
  controlsOverlay.addEventListener("click", (e)=>{ if(e.target===controlsOverlay) setControlsOpen(false); });

  lbClose.addEventListener("click", () => lbOverlay.style.display = "none");
  lbOverlay.addEventListener("click", (e)=>{ if(e.target===lbOverlay) lbOverlay.style.display="none"; });

  // ========= Drawing =========
  function drawBackground(){
    const W=canvas.width, H=canvas.height;

    // If background.png loads, use it; otherwise gradient.
    if (bgImg && bgImg.complete && bgImg.naturalWidth > 0){
      const s = Math.max(W/bgImg.width, H/bgImg.height);
      const w=bgImg.width*s, h=bgImg.height*s;
      ctx.drawImage(bgImg, (W-w)/2, (H-h)/2, w, h);
      // soft veil
      ctx.fillStyle = "rgba(0,0,0,.10)";
      ctx.fillRect(0,0,W,H);
      return;
    }

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#0b1020");
    g.addColorStop(1, "#0a1a2a");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // stars
    ctx.fillStyle = "rgba(255,255,255,.12)";
    for (let i=0;i<120;i++){
      const x = (i*9973) % W;
      const y = (i*7919) % H;
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function drawGround(){
    const W=canvas.width, H=canvas.height;
    const groundY = Math.floor(H*0.82);

    // ‚Äútracks‚Äù stripe
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fillRect(0, groundY, W, Math.floor(H*0.18));

    // rail line
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.lineWidth = Math.max(2, Math.floor(devicePixelRatio*1.5));
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(W, groundY);
    ctx.stroke();

    // ties
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth = Math.max(1, Math.floor(devicePixelRatio));
    for (let x=0; x<W; x += Math.floor(W*0.04)){
      ctx.beginPath();
      ctx.moveTo(x, groundY+Math.floor(H*0.03));
      ctx.lineTo(x+Math.floor(W*0.02), groundY+Math.floor(H*0.06));
      ctx.stroke();
    }
  }

  function drawElf(px, py, pw, ph){
    // cute simple ‚Äúelf‚Äù: body + hat + face
    ctx.save();
    ctx.translate(px, py);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,.25)";
    ctx.beginPath();
    ctx.ellipse(pw*0.45, ph*0.95, pw*0.35, ph*0.10, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = "rgba(140, 255, 220, .85)";
    roundRect(ctx, pw*0.18, ph*0.35, pw*0.55, ph*0.55, pw*0.18);
    ctx.fill();

    // head
    ctx.fillStyle = "rgba(255, 235, 210, .92)";
    ctx.beginPath();
    ctx.arc(pw*0.48, ph*0.28, Math.min(pw,ph)*0.18, 0, Math.PI*2);
    ctx.fill();

    // hat
    ctx.fillStyle = "rgba(255, 80, 120, .85)";
    ctx.beginPath();
    ctx.moveTo(pw*0.25, ph*0.28);
    ctx.lineTo(pw*0.70, ph*0.26);
    ctx.lineTo(pw*0.50, ph*0.02);
    ctx.closePath();
    ctx.fill();

    // bell
    ctx.fillStyle = "rgba(255, 210, 90, .9)";
    ctx.beginPath();
    ctx.arc(pw*0.50, ph*0.05, Math.min(pw,ph)*0.06, 0, Math.PI*2);
    ctx.fill();

    // eyes
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.beginPath();
    ctx.arc(pw*0.42, ph*0.28, Math.min(pw,ph)*0.03, 0, Math.PI*2);
    ctx.arc(pw*0.54, ph*0.28, Math.min(pw,ph)*0.03, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawSpike(ox, oy, ow, oh){
    ctx.save();
    ctx.translate(ox, oy);

    // base shadow
    ctx.fillStyle = "rgba(0,0,0,.20)";
    ctx.fillRect(0, oh*0.92, ow, oh*0.08);

    // spike triangles
    const spikes = Math.max(3, Math.floor(ow / (20*devicePixelRatio)));
    const step = ow / spikes;

    ctx.fillStyle = "rgba(255,255,255,.80)";
    for (let i=0;i<spikes;i++){
      const x0 = i*step;
      const x1 = x0 + step*0.5;
      const x2 = x0 + step;

      ctx.beginPath();
      ctx.moveTo(x0, oh);
      ctx.lineTo(x1, 0);
      ctx.lineTo(x2, oh);
      ctx.closePath();
      ctx.fill();
    }

    // outline
    ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.lineWidth = Math.max(1, Math.floor(devicePixelRatio));
    ctx.strokeRect(0, 0, ow, oh);

    ctx.restore();
  }

  function drawSnowmanDecoration(W,H){
    // just a cute ‚Äúsnowman blob‚Äù on the right so it feels festive
    const groundY = Math.floor(H*0.82);
    const x = Math.floor(W*0.84);
    const y = Math.floor(groundY - H*0.28);

    ctx.save();
    ctx.translate(x,y);

    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.beginPath();
    ctx.arc(W*0.05, H*0.16, Math.min(W,H)*0.05, 0, Math.PI*2);
    ctx.arc(W*0.05, H*0.08, Math.min(W,H)*0.035, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,.45)";
    ctx.beginPath();
    ctx.arc(W*0.04, H*0.075, Math.min(W,H)*0.006, 0, Math.PI*2);
    ctx.arc(W*0.06, H*0.075, Math.min(W,H)*0.006, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawScene(){
    const W=canvas.width, H=canvas.height;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    drawBackground();
    drawGround();

    drawSnowmanDecoration(W,H);

    // player
    const pw = Math.max(42*devicePixelRatio, W*0.055);
    const ph = Math.max(58*devicePixelRatio, H*0.095);
    const px = W * player.x;
    const py = H * player.y;
    drawElf(px, py, pw, ph);

    // obstacles
    obstacles.forEach(o=>{
      drawSpike(W*o.x, H*o.y, W*o.w, H*o.h);
    });

    // paused overlay
    if (running && paused){
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = `${Math.max(16*devicePixelRatio, 20)}px system-ui`;
      ctx.fillText("Paused ‚Äî close Controls to continue", Math.floor(W*0.04), Math.floor(H*0.10));
    }
  }

  // ========= Mechanics =========
  function jump(){
    if (!running || paused) return;
    if (player.onGround){
      player.vy = -1.05;
      player.onGround = false;
    }
  }

  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  function spawnObstacle(){
    const w = Math.max(0.016, 0.030 + (rand()-0.5)*0.008);
    const height = Math.min(0.34, Math.max(0.12, 0.14 + rand()*0.18 + difficulty*0.06));
    obstacles.push({
      x: 1.05,
      y: 0.82 - height,
      w,
      h: height,
      passed: false,
    });
  }

  function step(ts){
    if (!running) return;

    if (paused){
      drawScene();
      rafId = requestAnimationFrame(step);
      return;
    }

    if (!startTs){ startTs = ts; lastTs = ts; }
    const dt = Math.min(0.035, (ts - lastTs) / 1000);
    lastTs = ts;

    remaining = Math.max(0, RUN_SECONDS - (ts - startTs)/1000);
    setTime(remaining);

    const t = 1 - (remaining / RUN_SECONDS);
    difficulty = Math.min(1, 0.15 + t*0.95);

    // gravity
    player.vy += 2.45 * dt;
    player.y += player.vy * dt;

    const groundTop = 0.82 - 0.10;
    if (player.y >= groundTop){
      player.y = groundTop;
      player.vy = 0;
      player.onGround = true;
    }

    const speed = 0.62 + difficulty*0.95;

    spawnT -= dt;
    if (spawnT <= 0){
      spawnObstacle();
      const minGap = 0.45 - difficulty*0.22;
      const jitter = (rand()*0.22);
      spawnT = Math.max(0.18, minGap + jitter);
    }

    obstacles.forEach(o => o.x -= speed * dt);

    // collision + scoring (hitbox smaller than drawn elf)
    const px = player.x + 0.012;
    const py = player.y + 0.020;
    const pw = 0.032;
    const ph = 0.070;

    for (const o of obstacles){
      if (!o.passed && o.x + o.w < player.x){
        o.passed = true;
        setScore(score + 1);
      }

      const bx = o.x + 0.003;
      const by = o.y + 0.010;
      const bw = Math.max(0.01, o.w - 0.006);
      const bh = Math.max(0.01, o.h - 0.012);

      if (aabb(px,py,pw,ph, bx,by,bw,bh)){
        setLives(lives - 1);
        player.vy = -0.75;
        player.onGround = false;
        o.x = player.x - o.w - 0.02;

        if (lives <= 0){
          endRun(false);
          return;
        }
      }
    }

    obstacles = obstacles.filter(o => o.x > -0.25);

    drawScene();

    if (remaining <= 0){
      endRun(true);
      return;
    }

    rafId = requestAnimationFrame(step);
  }

  async function endRun(survived){
    running = false;
    paused = false;
    stopGateTicker();
    startBtn.disabled = true;

    const now = new Date();
    const day = ymd(now);
    const name = sanitizeName(getUsername()) || "Guest";
    const timeTaken = RUN_SECONDS - remaining;

    const flavor = survived ? "‚úÖ Run complete!" : "üí• Wiped out!";
    msgEl.textContent = `${flavor} Submitting score‚Ä¶`;

    try{
      const r = await submitScore(name, day, score, timeTaken);
      msgEl.textContent = (r && r.ok)
        ? `üèÅ ${flavor} Score: ${score}. Posted to leaderboard.`
        : `‚ö†Ô∏è ${flavor} Score: ${score}. Submit failed (server).`;
    }catch{
      msgEl.textContent = `‚ö†Ô∏è ${flavor} Score: ${score}. Submit failed (network).`;
    }

    await openLeaderboard();
    startGateTicker();
  }

  // ========= Leaderboard =========
  function renderLeaderboardList(rows){
    lbList.innerHTML = "";
    if (!rows || rows.length === 0){
      lbList.innerHTML = `<div class="lbRow"><div class="left"><div class="rank">‚Äî</div><div class="name">No scores yet today</div></div><div class="meta">‚ùÑÔ∏è</div></div>`;
      return;
    }
    rows.forEach((r,i)=>{
      const el = document.createElement("div");
      el.className="lbRow";
      el.innerHTML = `<div class="left"><div class="rank">${i+1}</div><div class="name">${String(r.name||"").replace(/</g,"&lt;")}</div></div><div class="meta">${r.score} pts ‚Ä¢ ${Number(r.time||0).toFixed(1)}s</div>`;
      lbList.appendChild(el);
    });
  }

  async function openLeaderboard(){
    const now = new Date();
    const day = ymd(now);
    lbSub.textContent = `Day ${dayIndex(now)} / 11 ‚Ä¢ ${day}`;
    try{
      const r = await fetchLeaderboard(day, 10);
      if (r && r.ok) renderLeaderboardList(r.top || []);
      else renderLeaderboardList([]);
    }catch{
      renderLeaderboardList([]);
    }
    lbOverlay.style.display = "flex";
  }
  leaderBtn.addEventListener("click", openLeaderboard);

  // ========= Start flow (wait for controls close) =========
  function waitForControlsClose(){
    return new Promise(resolve => {
      if (controlsOverlay.style.display !== "flex") return resolve();

      const handler = () => {
        if (controlsOverlay.style.display !== "flex") {
          controlsClose.removeEventListener("click", handler);
          resolve();
        }
      };
      controlsClose.addEventListener("click", handler);
    });
  }

  async function startDailyRun(){
    const now = new Date();
    if (!inWindow(now)) { updateGateUI(); return; }
    if (!assetsReady){
      msgEl.textContent = "‚è≥ Loading‚Ä¶";
      return;
    }

    bootstrapUser();
    const name = sanitizeName(getUsername()) || "Guest";
    const day = ymd(now);

    startBtn.disabled = true;
    msgEl.textContent = "Checking in (one play per name per day)‚Ä¶";

    try{
      const r = await checkinNameForToday(name, day);
      if (!r || !r.ok){
        msgEl.textContent = "‚ö†Ô∏è Server error. Try again.";
        startBtn.disabled = false;
        return;
      }
      if (!r.allowed){
        msgEl.textContent = "‚úÖ Already played today (for this name). Come back tomorrow!";
        startBtn.disabled = true;
        await openLeaderboard();
        return;
      }

      resetRun();
      running = true;
      paused = true;
      stopGateTicker();

      setControlsOpen(true);
      msgEl.textContent = `‚è∏ Ready, ${name}. Close Controls to start!`;

      await waitForControlsClose();

      paused = false;
      msgEl.textContent = `üöÇ GO, ${name}! Tap/Click/Space to jump.`;
      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(step);

    }catch{
      msgEl.textContent = "‚ö†Ô∏è Network error. Try again.";
      startBtn.disabled = false;
    }
  }
  startBtn.addEventListener("click", startDailyRun);

  // Pointer + keyboard jump
  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space"){
      e.preventDefault();
      if (controlsOverlay.style.display === "flex") return;
      jump();
    }
  });

  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    if (controlsOverlay.style.display === "flex") return;
    jump();
  }, { passive:false });

  // ========= Gate UI =========
  function updateGateUI(){
    const now = new Date();
    bootstrapUser();

    if (now < START){
      msgEl.textContent = "üöÇ Not open yet. Opens 12/20/2025 at 00:01.";
      startBtn.disabled = true;
      dayEl.textContent = "‚Äî";
      return;
    }
    if (now > END){
      msgEl.textContent = "‚ùÑÔ∏è Event ended. Closed after 12/30/2025 23:59.";
      startBtn.disabled = true;
      dayEl.textContent = "‚Äî";
      return;
    }

    dayEl.textContent = `${dayIndex(now)} / 11`;
    if (!running) msgEl.textContent = "üéÅ One play per name per day. Good luck.";
    startBtn.disabled = running ? true : false;
  }

  controlsBtn.addEventListener("click", ()=>setControlsOpen(true));

  // ========= Init =========
  bootstrapUser();
  updateGateUI();
  startGateTicker();
  drawScene();
})();
</script>
</body>
</html>
